<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="好记性不如烂笔头，多看多写多分享。"><title>18：Python3-模块 | 常灿光个人博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">18：Python3-模块</h1><a id="logo" href="/.">常灿光个人博客</a><p class="description">常灿光</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">18：Python3-模块</h1><div class="post-meta">Aug 28, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p><img src="https://i.imgur.com/JV2b3QM.jpg" alt=""></p>
<h1 id="Python3-模块"><a href="#Python3-模块" class="headerlink" title="Python3 模块"></a>Python3 模块</h1><p>在前面的几个章节中，我们大部分是在脚本上使用python解释器来编程的，如果你从Python解释器退出再进入，那么你定义的所有的方法和变量就都消失了。<br>为此Python提供了一个方法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引用，以使用该模块中的函数和功能。这也是使用Python标准库的方法。</p>
<p>下面是一个使用python标准库中模块的例子。</p>
<pre><code>#!/usr/bin/python3
import sys
print(&quot;命令行参数如下：&quot;)
for i in sys.argv:
    print(i)
print(&apos;\n\nPython 路径为：&apos;, sys.path, &apos;\n&apos;)
</code></pre><p>执行结果如下所示：</p>
<pre><code>命令行参数如下：
C:\Program Files\JetBrains\PyCharm 2017.1.4\helpers\pycharm\_jb_unittest_runner.py
Python 路径为： [&apos;E:\\PycharmProjects\\PyStudyBase&apos;, &apos;C:\\Program Files\\JetBrains\\PyCharm 2017.1.4\\helpers\\pycharm&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32\\python36.zip&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32\\DLLs&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32\\lib&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\site-packages&apos;, &apos;E:\\PycharmProjects\\PyStudyBase&apos;] 
</code></pre><ol>
<li>import sys引入python标准库中的sys.py模块；这是引入某一模块的方法。</li>
<li>sys.argv是一个包含命令行参数的列表。</li>
<li>sys.path包含了一个python解释器自动查找所需模块的路径的列表。</li>
</ol>
<h1 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h1><p>想使用python源文件，只需要在另一个源文件中执行import语句，语法如下：</p>
<pre><code>import module1[, module2[,... moduleN]
</code></pre><p>当解释器遇到import语句的时候，如果模块在当前的搜索路径就会被导入。<br>搜索路径是一个解释器会先进行搜索所在目录的列表，如果想要导入模块support，需要把命令放在脚本的顶端：</p>
<p>support.py 文件代码为：</p>
<pre><code>#!/usr/bin/python3
# Filename: support.py

def print_func( par ):
print (&quot;Hello : &quot;, par)
return
</code></pre><p>test.py 引入 support 模块：</p>
<pre><code>#!/usr/bin/python3
# Filename: test.py

# 导入模块
import support

# 现在可以调用模块里包含的函数了
support.print_func(&quot;Runoob&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>Hello :  Runoob
</code></pre><p>一个模块只会被导入一次，不管你执行了多少次import，这样可以防止导入模块被一遍又一遍地执行。<br>当我们使用import语句的时候，python解释器是怎么找到对应的文件的呢？？<br>这就涉及到python的搜索路径，搜索路径是由一系列目录名组成的，python解释器就依次从这些目录中去寻找所需要引入的模块。这看起来很像环境变量，事实上，也可通过定义环境变量的方式来确定搜索路径。<br>搜索路径在python编译或者安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&apos;&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32\\python36.zip&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32\\DLLs&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32\\lib&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32&apos;, &apos;C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\site-packages&apos;]
&gt;&gt;&gt;
</code></pre><p>sys.path输出是一个列表，其中第一项是空串“”，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p>
<p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p>
<p>了解搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p>
<p>现在，在解释器的当前目录或者sys.path中的一个目录来创建一个fibo.py的文件，代码如下：</p>
<pre><code># 斐波那契(fibonacci)数列模块

def fib(n):# 定义到 n 的斐波那契数列
a, b = 0, 1
while b &lt; n:
print(b, end=&apos; &apos;)
a, b = b, a+b
print()

def fib2(n): # 返回到 n 的斐波那契数列
result = []
a, b = 0, 1
while b &lt; n:
result.append(b)
a, b = b, a+b
return result
</code></pre><p>然后进入Python解释器，使用下面的命令导入这个模块：</p>
<pre><code>import fibo
</code></pre><p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p>
<p>可以使用模块名称来访问函数：</p>
<pre><code>#!/usr/bin/python3

import fibo

print(fibo.fib(1000))
print(fibo.fib2(100))
</code></pre><p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p>
<pre><code>fib = fibo.fib
print(fib(1000))
</code></pre><p>输出结果如下：</p>
<pre><code>1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 
</code></pre><h1 id="from…import语句"><a href="#from…import语句" class="headerlink" title="from…import语句"></a>from…import语句</h1><p>Python的from语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p>
<pre><code>from modname import name1[, name2[, ... nameN]]
</code></pre><p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p>
<pre><code>from fibo import fib, fib2
fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p>
<h1 id="From…import-语句"><a href="#From…import-语句" class="headerlink" title="From…import* 语句"></a>From…import* 语句</h1><p>把一个模块的所有内容都导入到当前的命名空间也是可行的。然而这种声明不该被多次使用。</p>
<h1 id="深入模块"><a href="#深入模块" class="headerlink" title="深入模块"></a>深入模块</h1><p>模块除了方法定义之外，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入的时候才会被执行。每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。<br>所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞乱。</p>
<p>从另一个方面，当你确定知道你在做什么的电话，你也可以通过modname.itemname这样的表示法来访问模块内的函数。</p>
<p>模块是可以导入其他模块的，在一个模块（或者脚本，或者其他地方）的最前面是用import来导入一个模块，当然这只是一个惯例，而不是强制的，被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
<p>还有一种导入的方法，可以使用import直接把模块内（函数，变量的）名称导入到当前操作模块。比如：</p>
<pre><code>&gt;&gt;&gt; from fibo import fib, fib2
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo这个名称是没有定义的）。这还有一种方法，可以一次性的把模块中的所有函数或者变量名称都导入到当前模块的字符表中。</p>
<pre><code>&gt;&gt;&gt; from fibo import *
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><p>这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况，Python程序员不是用这种方法，因为引入的其他来源的命名，很可能覆盖了自己已有的定义。</p>
<h1 id="—name-属性"><a href="#—name-属性" class="headerlink" title="—name_属性"></a>—name_属性</h1><p>一个模块被另一个程序第一次引入的时候，其主程序将被运行，如果我们想在模块被引入的时候，模块中的某一程序块不被执行，我么可以使用<em>name</em>属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code>#!/usr/bin/python3
# Filename: support.py

if __name__ == &apos;__main__&apos;:
   print(&apos;程序自身在运行&apos;)
else:
   print(&apos;我来自另一模块&apos;)
</code></pre><p>运行输出如下：</p>
<pre><code>程序自身在运行
</code></pre><p>将support.py文件import到另一个文件中：</p>
<pre><code>#!/usr/bin/python3

import support
</code></pre><p>此时运行结果如下：</p>
<pre><code>我来自另一模块
</code></pre><p><strong>说明：</strong> 每一个模块都有一个<em>name</em>属性，当其值是”<em>main</em>“时候，表明该模块自身在运行，否是就是被引入。</p>
<h1 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h1><p>内置的函数dir()可以找到模块内定义的所有名称，并且以一个字符串列表的形式返回：</p>
<pre><code>#!/usr/bin/python3

import fibo
print(dir(fibo))

import sys
print(dir(sys))
</code></pre><p>运行结果如下：</p>
<pre><code>[&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;fib&apos;, &apos;fib2&apos;]
[&apos;__displayhook__&apos;, &apos;__doc__&apos;, &apos;__excepthook__&apos;, &apos;__interactivehook__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;__stderr__&apos;, &apos;__stdin__&apos;, &apos;__stdout__&apos;, &apos;_clear_type_cache&apos;, &apos;_current_frames&apos;, &apos;_debugmallocstats&apos;, &apos;_enablelegacywindowsfsencoding&apos;, &apos;_getframe&apos;, &apos;_git&apos;, &apos;_home&apos;, &apos;_xoptions&apos;, &apos;api_version&apos;, &apos;argv&apos;, &apos;base_exec_prefix&apos;, &apos;base_prefix&apos;, &apos;builtin_module_names&apos;, &apos;byteorder&apos;, &apos;call_tracing&apos;, &apos;callstats&apos;, &apos;copyright&apos;, &apos;displayhook&apos;, &apos;dllhandle&apos;, &apos;dont_write_bytecode&apos;, &apos;exc_info&apos;, &apos;excepthook&apos;, &apos;exec_prefix&apos;, &apos;executable&apos;, &apos;exit&apos;, &apos;flags&apos;, &apos;float_info&apos;, &apos;float_repr_style&apos;, &apos;get_asyncgen_hooks&apos;, &apos;get_coroutine_wrapper&apos;, &apos;getallocatedblocks&apos;, &apos;getcheckinterval&apos;, &apos;getdefaultencoding&apos;, &apos;getfilesystemencodeerrors&apos;, &apos;getfilesystemencoding&apos;, &apos;getprofile&apos;, &apos;getrecursionlimit&apos;, &apos;getrefcount&apos;, &apos;getsizeof&apos;, &apos;getswitchinterval&apos;, &apos;gettrace&apos;, &apos;getwindowsversion&apos;, &apos;hash_info&apos;, &apos;hexversion&apos;, &apos;implementation&apos;, &apos;int_info&apos;, &apos;intern&apos;, &apos;is_finalizing&apos;, &apos;maxsize&apos;, &apos;maxunicode&apos;, &apos;meta_path&apos;, &apos;modules&apos;, &apos;path&apos;, &apos;path_hooks&apos;, &apos;path_importer_cache&apos;, &apos;platform&apos;, &apos;prefix&apos;, &apos;set_asyncgen_hooks&apos;, &apos;set_coroutine_wrapper&apos;, &apos;setcheckinterval&apos;, &apos;setprofile&apos;, &apos;setrecursionlimit&apos;, &apos;setswitchinterval&apos;, &apos;settrace&apos;, &apos;stderr&apos;, &apos;stdin&apos;, &apos;stdout&apos;, &apos;thread_info&apos;, &apos;version&apos;, &apos;version_info&apos;, &apos;warnoptions&apos;, &apos;winver&apos;]
</code></pre><p>如果没有给定参数，那么dir()函数会罗列出当前定义的所有的属性。</p>
<h1 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h1><p>Python本身带着一些标准的模块库，在Python库参考文档中将会介绍到（就是后面的“库参考文档”）。</p>
<p>有些模块直接被构建在解析器里面，这些虽然不是一些语言内置的功能功能，但是他却能够很高效的使用，甚至系统级别调用都是没有问题的。这些组件会根据不同的操作系统进行不同形式的配置，比如winreg这个模块就只会提供给windows系统。</p>
<p>应该注意到这有一个特别的模块sys，它内置在每一个Python解释其中。变量sys.ps1和sys.ps2定义了主提示符和副提示符所对应的字符串。</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.ps1
&apos;&gt;&gt;&gt; &apos;
&gt;&gt;&gt; sys.ps2
&apos;... &apos;
&gt;&gt;&gt; sys.ps1 = &apos;C&gt;&apos;
C&gt;
C&gt;
C&gt;
C&gt;print(&apos;Bruce Chang&apos;)
Bruce Chang
</code></pre><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包是一种管理Python模块命名空间的形式，采用“点模块名称”。比如：一个模块的名称是A.B，那么他表示一个包A中的子模块B。</p>
<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心模块重名的情况。这样不同的作者都可以提供NumPy模块，或者是Python图形库。不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个包），现在存在很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如：.wav、.mp3）所以需要有一个不断增加的模块，用来在不同的格式之间转换。并且针对这些音频数据，还有很多不同的操作（例如：混音、添加回声、增加均衡器功能、创建人体立体声效果），所以还需要一组怎么也写不完的模块来处理这些操作。</p>
<p>这里给出了一种可能的包结构（在分层的文件系统中）：</p>
<pre><code>sound/                          顶层包
  __init__.py               初始化 sound 包
  formats/                  文件格式转换子包
          __init__.py
          wavread.py
          wavwrite.py
          aiffread.py
          aiffwrite.py
          auread.py
          auwrite.py
          ...
  effects/                  声音效果子包
          __init__.py
          echo.py
          surround.py
          reverse.py
          ...
  filters/                  filters 子包
          __init__.py
          equalizer.py
          vocoder.py
          karaoke.py
          ...
</code></pre><p>在导入一个包的时候，Python会根据sys.path中的目录来寻找这个包中包含的子目录。目录只有包含一个叫做 <strong>init</strong>.py的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如是String）不小心影响搜索路径中的有效模块。最简单的情况，放一个空的file： <strong>init</strong>.py就可以了。当然这个文件中也可以包含一些初始化代码。</p>
<p>用户可以每次只导入一个包里面的特定模块，比如：</p>
<pre><code>import sound.effects.echo
</code></pre><p>这样将导入子模块：sound.effects.echo。但是在我们需要使用的时候，我们必须使用全名路径去访问。</p>
<pre><code>sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre><p>还有一种导入子模块的方法是：</p>
<pre><code>from sound.effects import echo
</code></pre><p>这样同样会导入子模块echo，并且他不需要那些冗长的前缀，所以他可以这样使用：</p>
<pre><code>echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre><p>还有一种变化就是直接导入一个函数或者变量：</p>
<pre><code>from sound.effects.echo import echofilter
</code></pre><p>同样的，这种方法会导入子模块echo，并且可以直接使用他的echofiter()函数：</p>
<pre><code>echofilter(input, output, delay=0.7, atten=4)
</code></pre><p><strong>注意：</strong> 当使用from package import item这种形式的时候，对应的item即可以是包里面的子模块，也可以是包里面定义的其它的名称，比如<strong>函数、类或者变量。</strong></p>
<p>import语句会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入，如果还没有知道，那么，sorry一个exc.ImportError异常就被抛出来了。反之，如果使用形如import item.subitem.subsubitem这种形式导入，除了最后一项，都必须是包，而且最后一项可以是模块或者是包，，<strong>但不可以是类、函数或者变量的名字。</strong></p>
<h1 id="从一个包中导入"><a href="#从一个包中导入" class="headerlink" title="从一个包中导入*"></a>从一个包中导入*</h1><p>如果我们使用from sound.effects import *会发生什么呢？Python会进入文件系统，找到这个包里面所有的子模块，一个一个的把他们都导入进来。</p>
<p>但是很不幸，这个方法在windows平台上工作的就不是非常好，因为windows是一个大小写不区分的系统，在该系统上，没有人敢担保一个叫做ECHO.py的文件导入后是echo还是Echo甚至是ECHO。</p>
<p>为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。<br>导入语句遵循如下规则，如果包定义文件<strong>init</strong>.py 存在一个叫做 <strong>all</strong> 的列表变量，那么在使用 from package import *的时候，就把这个列表中的所有名字作为包内容导入了。</p>
<p>作为包的作者，可别忘了在更新包之后保证<strong>all</strong> 也更新了。这里有一个例子，在file:sounds/effects/<strong>init</strong>.py中包含如下代码：</p>
<pre><code>__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre><p>这表示当你使用from sound.effects import <em>这种用法的时候，你只会导入包里面这三个子模块。<br>如果<strong>all</strong>没有定义，那么使用 from sound.effects import </em>这种语法的时候，就不会导入包sound.effects里面的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来，并且他不会破坏掉我们在这句话之前导入的所有明确制定的模块。看下这部分代码：</p>
<pre><code>import sound.effects.echo
import sound.effects.surround
from sound.effects import *
</code></pre><p>在执行 from…import前，包sound.effects中的echo和surround模块都会被导入到当前的命名空间中了。（当然如果定义了<strong>all</strong>就没问题了）</p>
<p>通常我们不主张使用这种方法来导入模块，因为这种方法会导致代码的可读性降低，不过这样倒的确是可以省去不少前键盘的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p>
<p>记住，使用from Package import specific_submodule这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p>
<p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而且你又想导入兄弟包（同级别的包），你就得使用导入绝对的路径来导入，比如，如果模块sound.filters.vocoder要使用包sound.effects中的模块echo，你就要写成 form sound.effect import echo。</p>
<pre><code>from . import echo
from .. import formats
from ..filters import equalizer
</code></pre><p>无论是隐式的还是显式的相对导入都是从当前的模块开始的，主模块的名字永远是”<strong>main</strong>“，一个python应用程序的主模块，应当总是使用绝对路径引用。</p>
<p>包还提供一个额外的属性<strong>path</strong>，这是一个目录列表，里面每一个包含的目录都有为这个包服务的<strong>init</strong>.py，但是这个功能并不常用，一般用来扩展包里面的模块。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://201216323.tech/2017/08/28/18：Python3-模块/" data-id="cj7e6ngnh000850sgsfqczh32" class="article-share-link">分享</a><div class="tags"><a href="/tags/Python/">Python</a></div><div class="post-nav"><a href="/2017/09/05/1：Android5-0中TextInputLayout和Snackbar的使用。/" class="pre"> 1：Android5.0中TextInputLayout和Snackbar的使用。</a><a href="/2017/08/27/17：Python3-数据结构/" class="next">17：Python3 数据结构</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://201216323.tech"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Html5/" style="font-size: 15px;">Html5</a> <a href="/tags/友盟/" style="font-size: 15px;">友盟</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/熟练使用Android-Studio，亲自体验，持续更新。/">熟练使用Android Studio，亲自体验，持续更新。</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/MVP设计模式的一次深入探索和优化/">MVP设计模式的一次深入探索和优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/JNI开发-一点一点搞清楚NDK开发的步骤/">JNI开发----一点一点搞清楚NDK开发的步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/JNI开发-复习曾经学习过的C语言/">JNI开发----复习曾经学习过的C语言</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/过去的2016，期待的2017，我与北京继续相伴。/">过去的2016，期待的2017，我与北京继续相伴。</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/事件总线之EventBus/">事件总线之EventBus</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/图片加载框架之Fresco/">图片加载框架之Fresco</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/图片加载框架之Picasso/">图片加载框架之Picasso</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/图片加载框架之Glide/">图片加载框架之Glide</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/个人收藏的一些很有性价比的Github链接/">个人收藏的一些很有性价比的Github链接</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">常灿光个人博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>